

## JVM

#### 1. jvm 内存结构

运行时数据区

* 线程独有：程序计数器、栈、本地方法栈
* 线程间共享：堆、堆外内存（永久代或元空间、代码缓存）

##### **1.1 程序计数器**

> 是块啥？存啥？有啥用？线程私有？异常？

一小块内存空间，线程私有。

下一条指令的地址，由执行引擎读取，实现代码的流程控制(循环、跳转、选择等)

作用：多线程，记录当前线程执行的位置；JVM字节码解释器需要改变PC寄存器来明确下一条指令

1. JVM中的程序计数寄存器（Program Counter Register）中，Register的命名源于CPU的寄存器，**寄存器存储指令相关的现场信息**。CPU只有把数据装载到寄存器才能够运行。
2. 这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。**JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟**。
3. 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。
4. 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。
5. 任何时间一个线程都只有一个方法在执行，也就是所谓的**当前方法**。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefned）。
6. 它是**程序控制流**的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
7. 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
8. 它是**唯一一个**在Java虚拟机规范中没有规定任何OutofMemoryError情况的区域。

##### **1.2 本地方法栈**

> 线程私有？存啥？异常？本地方法是啥？

线程私有，管理本地方法的调用，可固定或可动态扩展，可能`stackOverFlowError`或`outOfMemoryError`,本地方法栈中登记本地方法，在执行引擎执行时加载本地方法库

1. **Java虚拟机栈于管理Java方法的调用，而本地方法栈用于管理本地方法的调用**。
2. 本地方法栈，也是线程私有的。
3. 允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面和虚拟机栈相同）
   - 如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个stackoverflowError 异常。
   - 如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个outofMemoryError异常。
4. 本地方法一般是使用C语言或C++语言实现的。
5. 它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。

> Hotspot将本地方法栈和虚拟机栈合二为一

##### **1.3 Java虚拟机栈**

> 线程私有？有啥用？存啥？栈帧里有啥？分别存啥？异常？参数？

线程私有，生命周期同线程，每次方法调用的数据都是通过栈传递的，**对应着一次次的Java方法调用**

栈由一个个栈帧组成，**栈帧：**局部变量表、操作数栈、动态链接、方法出口信息。**每个方法对应一个栈帧**

当前栈帧、当前方法、当前类

不同线程中所包含的栈帧是不允许存在相互调用的

* **局部变量表**：数字数组，存储方法参数和局部变量。**数据类型**：基本数据类型、对象引用、`returnAddress`返回值类型。**容量大小是在编译器确定的**

  **`Slot`**：是局部变量表最基本的存储单元，32位以内的占一个`Slot`，64位的占2个`Slot`。`byte`、`short`、`char`在存储前会转为`int`，`boolean`也会转为`int`(0和1)，`long`和`double`占2个`Slot`

  每个`Slot`会被分配一个索引，通过索引可以访问到局部变量表里的值。如果当前帧是由构造方法或者实例方法创建的，那么该**对象引用this将会被存在`index`为0的`Slot`处**

  `Slot`是可以重复利用的，某个局部变量出了作用域后，改位置的`Slot`可以被重新利用

* **操作数栈**：往里面`push`或`pop`数据，**用于保存计算过程的中间结果，以及计算过程中变量临时的存储空间**。

  类型转换的小问题：

  - 因为 8 可以存放在 byte 类型中，所以压入操作数栈的类型为 byte ，而不是 int ，所以执行的字节码指令为 bipush 8

  - 但是存储在局部变量的时候，会转成 int 类型的变量：istore_4

  - m改成800之后，byte存储不了，就成了short型，sipush 800

    > 应该是为了节约栈空间吧

  栈顶缓存技术(`Top Of Stack Cashing`)：**`Hotspot`将栈顶元素全部存在物理CPU的寄存器中，以降低对内存的读写次数，提升效率**

* **动态链接**：为了支持当前方法的代码能够实现动态链接，每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。

  在调用时，根据常量池的符号，如`#7 Methodref #8.#31`，然后反复套娃，找到调用的方法信息，并进行调用

  > 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**

  为什么用常量池嘞？不同的方法都可能会调用，因此存一份即可，节约空间。常量池就是提供一些符号或者常量，便于指令识别

  > 静态链接和动态链接 - > 早期绑定和晚期绑定
  >
  > 静态链接：编译器确定，运行时不变，这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接
  >
  > 动态链接：编译期无法被确定，只能够在程序运行期将调用的方法的符号转换为直接引用
  >
  > 早期绑定：早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就**可以使用静态链接的方式将符号引用转换为直接引用**。
  >
  > 晚期绑定：如果被调用的方法在编译期无法被确定下来，**只能够在程序运行期根据实际的类型绑定相关的方法**，这种绑定方式也就被称之为晚期绑定。

* **方法返回地址**：正常是PC计数器的值作为返回地址

参数：-Xss：设置线程的最大栈空间



###### 1.3.1 方法的调用

1. 解析

   方法在程序真正运行之前就有一个可确定的调用版本，并且运行时不可改变，这类方法的调用被称为解析。即编译期可知，运行时不可变。

   > 方法调用的5个字节码指令
   >
   > 1. invokestatic：调用静态方法
   >
   > 2. invokespecial：调用实例构造器<init>()方法、私有方法和父类中的方法
   >
   > 3. invokevirtual：调用所有的虚方法
   >
   > 4. invokeinterface：调用接口，运行时再确定一个实现该接口的对象
   >
   > 5. invokedynamic：现在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法
   >
   >    只能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，如静态方法、私有方法、实例构造器、父类方法，再加上被final修饰的方法(尽管是被invokevirtual指令调用的)，这些方法调用会在类加载时就可以把符号引用解析为方法的直接引用，这些方法也成为“非虚方法”，与之相反的就是“虚方法”。

2. 分派

   可静态、可动态，又分单分派和多分派。因此构成静态单分派、静态多分派、动态单分派和动态多分派。

   2.1 静态分派

   所有依赖静态类型来决定方法执行版本的分派，成为静态分派

   其实具有动态性，也可归入解析里。

   > `Human human = new Man();`这里的`Human`称为**静态类型**，静态类型的变化仅仅在使用时发生，如强转；这里的`Man`称为**实际类型**或**运行时类型**，实际类型变化的结果在运行期才可确定。

   静态分派典型的应用就是**重载**

   虚拟机在判断重载时，是通过参数的静态类型，而不是实际类型作为判断依据的。由于静态类型编译期可知，那么Java编译期就根据静态类型确定用哪个重载版本了(或者说更适合的那个版本，不一定完全匹配，char -> int -> long -> float -> double)

   2.2 动态分派

   主要体现了Java中的**重写**。

   如何根据实际类型来进行分派呢？

   核心就是invokevirtual指令，解析过程如下：

   1. 找到操作数栈顶的第一个元素所指向的对象的**实际类型**，记类型C
   2. 如果类型C中找到**与常量中的描述符和简单名称都相符**的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找结束；不通过报异常`IllegalAccessError`
   3. 否则按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程
   4. 如果始终木有找到，则抛异常`AbstractMethodError`

   2.3 单分派和多分派

   宗量：方法的接受者与方法的参数

   根据分派基于的宗量的多少，分为单分派和多分派

   如重载就是多分派的，重写就是单分派的，大致可以这样理解

   因此Java目前是静态多分派和动态单分派的

   例子p312

   2.4 虚拟机动态分派的实现

   频繁地搜索类型元数据会很消耗性能，因此可以在方法区建立一个虚方法表(vtable)，类似的还有接口方法表，通过虚方法表的索引来代替元数据查找以提高性能。

   > HotSpot中虚方法表是最慢的了，在即时编译器执行时会有更多优化

   

   



##### **1.4 堆**

> 概述？内存结构？参数？

###### 1.4.1 概述

1. 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。
2. Java堆区在JVM启动的时候即被创建，其空间大小也就确定了，堆是JVM管理的最大一块内存空间，并且堆内存的大小是可以调节的。
3. 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。
4. 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，**TLAB**）。
5. 数组和对象可能永远不会存储在栈上（**不一定**），因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。
6. 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
   - 也就是触发了GC的时候，才会进行回收
   - 如果堆中对象马上被回收，那么用户线程就会收到影响，因为有stop the word
7. 堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。
8. 所有的对象基本都在堆上分配，现在可能有经过逃逸分析后再栈上分配，不是那么绝对



按照分代理论，堆的内存结构：

![image-20210419162921395](D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210419162921395.png)

![image-20210419162942793](D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210419162942793.png)

参数：-Xms：起始内存；-Xmx：最大内存。超过-Xmx会OOM。

> 通常两个参数设置一样，减小运行时频繁动态扩容缩容的消耗。

默认：电脑物理内存/64

查看设置的参数：jps   /  jstat -gc 进程id ;方式二：-XX:+PrintGCDetails



###### **1.4.2 年轻代和老年代**

Java中的对象一类是生命周期短的瞬时对象，创建消亡迅速；一类是生命周期长。

因此对应的将堆区分为了年轻代和老年代。年轻代又分为了：Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）

1. Eden：S0：S1 -> 8 :1 :1

   * -XX:SurvivorRatio = 8，可以修改

   年轻代：老年代 -> 1：2

   - 默认-XX:NewRatio = 2，表示新生代占1，老年代占2，新生代占整个堆的1/3
   - 可以修改-XX:NewRatio = 4，表示新生代占1，老年代占4，新生代占整个堆的1/5

2. 几乎所有对象都是在Eden区new出来的，大对象除外

3. 可以通过"-Xmn"设置新生代的最大内存大小（一般不改

   

###### **1.4.3 对象分配过程**

1. new的对象先放Eden区。此区有大小限制。
2. 当Eden区的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对Eden区进行垃圾回收（YGC/Minor GC），将Eden区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到Eden区。
3. 然后将Eden区中的剩余对象移动到幸存者0区，并将他们的年龄加1。
4. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区，并将年龄加1。
5. 其实就是每进行一次GC，年龄就加1，S0和S1区相互转换。
6. 啥时候能去老年区呢？可以设置次数。默认是15次。可以设置新生区进入老年区的年龄限制，设置 JVM 参数：**-XX:MaxTenuringThreshold**=N 进行设置
7. 在老年区，相对悠闲。当老年区内存不足时，再次触发GC：Major GC，进行老年区的内存清理
8. 若老年区执行了Major GC之后，发现依然无法进行对象的保存，就会产生OOM异常。

对象分配的特殊情况

1. 如果来了一个新对象，先看看 Eden 是否放的下？
   - 如果 Eden 放得下，则直接放到 Eden 区
   - 如果 Eden 放不下，则触发 YGC ，执行垃圾回收，看看还能不能放下？
2. 将对象放到老年区又有两种情况：
   - 如果 Eden 执行了 YGC 还是无法放不下该对象，那没得办法，只能说明是超大对象，只能直接放到老年代
   - 那万一老年代都放不下，则先触发FullGC ，再看看能不能放下，放得下最好，但如果还是放不下，那只能报 OOM
3. 如果 Eden 区满了，将对象往幸存区拷贝时，发现幸存区放不下啦，那只能便宜了某些新对象，让他们直接晋升至老年区

![image-20210419193341881](D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210419193341881.png)



##### **1.5 方法区(元空间)**

> 线程共享？内部结构，存啥？历史版本？垃圾回收？异常？参数？

JVM启动时创建，各个**线程共享**，内存可以是不连续的，可固定可扩展

###### **1.5.1 内部结构**

它用于存储已被虚拟机加载的**类型信息、常量、静态变量、即时编译器编译后的代码缓存**等

**类型信息**

1. 这个类型的完整有效名称（全名=包名.类名）
2. 这个类型直接父类的完整有效名（对于interface或是java.lang.Object，都没有父类）
3. 这个类型的修饰符（public，abstract，final的某个子集）
4. 这个类型直接接口的一个有序列表

域信息：即成员变量。包括：域名称、域类型、域修饰符

**方法信息：**

1. 方法名称
2. 方法的返回类型（包括 void 返回类型），void 在 Java 中对应的为 void.class
3. 方法参数的数量和类型（按顺序）
4. 方法的修饰符（public，private，protected，static，final，synchronized，native，abstract的一个子集）
5. 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）
6. 异常表（abstract和native方法除外），异常表记录每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

###### **1.5.2 静态变量存在哪儿？**

对象实例都在堆中，Hotspot把**静态变量与类型**在Java语言一端的映射**Class对象**存放在一起，**存储于Java堆之中**



##### **1.6 运行时常量池**

是方法区的一部分。

字节码文件(Class文件)里包含一项信息是常量池表，用于存放编译期生成的各种字面量与符号引用，在类加载之后，存放在方法区的运行时常量池中。

与字节码文件的常量池表不同的是，运行时常量池具有动态性，可以将运行时新产生的常量放入池中。

因为在方法区中，因此也有OOM异常。



**方法区的垃圾回收？**常量池中废弃的常量和不再使用的类型

只要常量池中的常量没有被任何地方引用，就可以被回收

**类回收**：需要判断一个类型是否属于“不再被使用的类”。

* 该类的所有实例都已经被回收
* 加载该类的类加载器已经被回收
* 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

满足三个条件，仅是被允许回收

###### **1.6.1 Hotspot方法区的历史演进**

JDK1.7之前，是永久代。JDK1.8之后是方法区。为啥改了呢？核心是**元空间不在虚拟机设置的内存中，而是使用本地内存**。

1. 为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。`Exception in thread 'dubbo client x.x connector' java.lang.OutOfMemoryError:PermGen space`而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。

2. 对永久代进行调优是很困难的。方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再用的类型，方法区的调优主要是为了降低

   Full GC

   1. 有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。
   2. 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻**。但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。

###### **1.6.2 字符串常量池 StringTable 为什么要调整位置？**

- JDK7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在Full GC的时候才会执行永久代的垃圾回收，而Full GC是老年代的空间不足、永久代不足时才会触发。
- 这就导致StringTable回收效率不高，而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。



**调参**：**-XX:MetaspaceSize** 和 **-XX:MaxMetaspaceSize**

异常：OutOfMemoryError:Metaspace









#### 2. jvm 调优参数

`-Xms 和 -Xmx`：设置对的初始和最大，一般设置为相同，防止堆动态增加和缩减带来的消耗

`-Xmn`：新生代的大小

`-XX:NewRatio`：配置年轻代和老年代在堆中的占比

`-XX:ServivorRatio`：新生代中Eden和S0/S1的占比

`-XX:MaxTenuringThreshold`：新生代垃圾的最大年龄

#### 3.什么是类加载？何时类加载？类加载流程？

**类加载子系统作用**：从文件系统或网络加载Class文件，类加载器只负责class文件的加载，加载的类信息存放在内存空间的方法区

**类加载的时机：**new一个对象时、访问或设置静态变量、调用静态方法、初始化一个子类若父类没初始化、虚拟机启动初始化`main`的类、反射、

**类加载的流程**：加载 => 链接(验证、准备、解析) => 初始化，这只是开始的顺序，很多步骤是交叉进行的

##### **加载**：

类的全限定名 => 类的二进制字节流，字节流所代表的类的静态存储结构 => 方法区的运行时数据结构，**在内存中生成`.Class`对象**，作为该类的访问入口

> 数组类本身不通过类加载器创建，由JVM在内存中动态构建。但数组的**元素类型**(数组去掉所有维度的类型)最终还是靠类加载器来加载的
>
> * 若数组的**组件类型**(去掉一个维度后)是引用类型，则递归采用定义的类加载器去加载。该数组会被标识在加载该组件类型的类加载器的类名称空间上
> * 如果组件类型不是引用类型，如int[]的组件类型为int，那么JVM会把数组标记为与引导类加载器关联

##### **链接**：

###### 验证

确保`class`文件的字节流包含当前虚拟机的要求，确保被加载类的正确性

* 文件格式验证：CAFEBABE开头、常量池的常量的类型tag、是否符合编码、Class文件是否完整或是否被附加信息

* 元数据验证：对类的元数据信息进行语义分析。如这个类是否有父类、继承是否合法(final)、是否实现了父类或接口要求实现的方法、字段和方法是否与父类矛盾(如覆盖父类final、参数一直的重载等)

* 字节码验证(最复杂)：校验分析Class文件的Code属性：保证类型合法、保证跳转不会跳出方法体外、保证类型转换的有效。

  > 通过了字节码验证，也不一定能保证一定安全。

* 符号引用验证：发生在链接的第三阶段，即解析时。确保解析能成功进行。

###### 准备

为类变量(`static`变量)分配内存，设初值(零值)

不包含用`final`修饰的`static`，因为`final`在编译时分配默认值，准备阶段会显示初始化

```java
public class HelloApp {
    private static int a = 1;//prepare：a = 0 ---> initial : a = 1


    public static void main(String[] args) {
        System.out.println(a);
    }
}
```

> 不为实例变量分配初始化，类变量分配在方法区，实例变量随对象分配在堆

###### 解析

**常量池内的符号引用转换为直接引用**(指向目标的指针)，主要针对类或接口、字段、类方法、接口方法、方法类型等

> 符号引用：一组符号来描述所引用的目标，可以是任意字面量，与JVM实现的内存布局无关，只要使用时能定位到目标即可
>
> 直接引用：可以直接指向目标的指针、相对偏移量、一个间接定位到目标的句柄

解析实际上伴随JVM执行完初始化后再执行

> 对同一个符号进行多次解析是很正常滴。JVM也可以对第一次解析进行缓存，并标记为已解析，避免重复解析；如果一个符号之前解析成功(失败)，那么之后也成功(失败)。
>
> 但是上面的对于`invokedynamic`指令不成立，`invokedynamic`指令触发解析，并不意味着另外的`invokedynamic`指令生效，它是用于动态语义支持的。动态指程序运行到这儿才进行解析；之前说的都是静态的，没执行代码前就提前进行解析

* 类或接口的解析
  * 如果不是数组类型，会将代表符号引用的全限定名传给该类的类加载器去加载这个类。加载过程，各种验证...加载其他类，可能异常，导致解析失败
  * 如果是数组类型，若数组的元素类型为对象，则按照上面进行加载；若为`java.lang.Integer`，那么由JVM直接生成一个代表该数组维度和元素的数组对象
  * 如果上面两步无异常，还需验证访问权限
* 字段解析：先解析所属类，然后找匹配的简单名称和字段描述符，若实现了接口，先找接口或父接口；如果木有，就找父类；若都木有，报错

##### **初始化**

其实是执行类构造方法`<clinit>()`的过程，此方法不用定义，是`javac`编译器自动根据**类变量和静态代码块的**信息合并来的

`<clinit>()`按照源文件出现顺序执行，其实是虚拟机视角下的`<init>()`

若该类有父类，JVM保证在执行子类的`<clinit>()`方法时，父类的`<clinit>()`方法已经执行完毕

`<clinit>()`方法多线程下同步加锁，阻塞线程被唤醒后，不会再次进入`<clinit>()`方法，该方法只会被执行一次



#### 4.知道哪些类加载器。类加载器之间的关系？

**两种类型**：引导类加载器`BootStrap ClassLoader` 和自定义类加载器`User-Defined ClassLoader`

所有派生于抽象类`ClassLoader`的类加载器都划分为自定义类加载器

**最常见的3种类加载器**：引导类加载器、扩展类加载器、系统类加载器

**启动(引导)类加载器**：`c/c++`实现，加载Java核心库(JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class.path路径下的内容)，JVM自身需要的类。

木有父加载器，不继承自`java.lang.ClassLoader`

只加载`java、javax、sun`等开头的类

**扩展类加载器**：Java编写，派生于`ClassLoader`类，父加载器为启动类加载器，加载ext扩展目录相关类库

**系统(应用程序)类加载器**：Java编写，派生于`ClassLoader`类，父加载器为扩展类加载器，负责加载环境变量或`java.class.path`类库，一般Java应用的类都有他来完成加载

> 用户自定义类加载器：



#### 5.类加载器的双亲委派了解么？结合 Tomcat 说一下双亲委派（Tomcat 如何打破双亲委托机制？...）

##### **5.1 双亲委派机制**

如果一个类加载器收到类加载请求，他不会先自己加载，而是将请求托付给父加载器去完成；每一层都如此，因此所有的加载请求最终都应该传递到最顶层的启动类加载器中；然后由启动类加载器开始，若自己可以完成类加载任务，则加载成功并返回；若自己不能完成加载，则交给子类加载器处理，一层层向下分配任务，直到子类加载器能加载。若所有类加载器都无法处理，则抛出异常

好处：

1. 避免类的重复加载
2. 保护程序安全，防止核心API被随意篡改
   - 自定义类：自定义java.lang.String 没有被加载。
   - 自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）

##### **5.2 `Tomcat`如何打破双亲委托机制？**

**原因**

* 一个web容器可能需要部署多个应用服务器，不同的应用服务器可能会依赖**同一个第三方类库的不同版本**。如果使用默认的类加载机制，是不会加载同一个类库的不同版本的哇，他只认全限定类名，且只有一份儿。
* web容器也有自己依赖的类库，要与应用程序隔离开

`Tomcat`如何打破嘞？

在原双亲委派机制的基础上，`Tomcat`添加了一个自定义类加载器，`tomcat7`之前的`Common`、`Catalina`、`Shared`三个类加载器，``tomcat8``后合并为`lib`包。这一部分仍然采用双亲委派机制。

`CommonClassLoader`：最基本的类加载器，加载的`class`可以被`tomcat`容器和各个`webapp`访问

`catalinaClassLoader`：tomcat容器中的私有的类加载器，对`webapp`不可见

`sharedClassLoader`：各个`webapp`共享的类加载器，对`webapp`可见，对`tomcat`容器不可见

**在`sharedClassLoader`下是java项目在打war包时，tomcat自动生成的类加载器，每个应用有一个专有的类加载器，这一部分就打破了双亲委派机制。**这样应用可以加载自己对应war里的class文件，但共享的文件还需向上级委托

> 在tomcat自定义的每个应用的类加载器中，还有一个jsp类加载器，jsp是一个servlet容器，每个类加载器只加载自己的jsp。tomcat会用一个线程去监听不同文件夹的修改时间，如果变化了就会重新加载，即jsp热部署





#### 6. 栈中存放什么数据，堆中呢？

栈中存的是栈帧，每个栈帧对应一个方法，里面存方法的参数、局部变量等。栈帧里有局部变量表、操作数栈、动态链接、方法返回地址等

堆中存放几乎所有的对象



#### 7. 大对象放在哪个内存区域

老年代，由于Full GC次数较少且比较慢，因此尽量避免出现过多的大对象

#### 8. 堆区如何分类

Java7之前逻辑上分为：年轻代、老年代、永久代

Java8之后逻辑上分为：年轻代、老年代、元空间

年轻代又分为：`Eden`区、幸存者0区(`From` 区)、幸存者1区(`To`区)

几乎所有的对象都在`Eden`区被`new`出来，都在新生代被销毁


- - -

##### **8.1 TLAB**

为啥要TLAB？堆是共享区域，并发环境下，多个线程操作同一地址，就需要用锁机制，这样会影响分配速度。

从线程角度来看，`JVM`为每个线程分配了一个私有的缓存区域`TLAB`(`Thread Local Allocation Buffer`)，包含在`Eden`空间内。

TLAB可以避免一系列的非线程安全问题，并**提升**内存分配的**吞吐量**，这成为快速分配策略

当一个线程的TLAB存满时，可以使用一块公共区域

一旦对象分配TLAB失败，**JVM会尝试使用加锁机制确保数据操作的原子性**



#### 10. HotSpot的算法实现细节(p81)

##### 10.1 根节点枚举

所有的垃圾收集器在根节点枚举时，必须STW。在可达性分析算法中，根节点枚举还是必须在**一个能保障一致性的快照**中才得以进行。

枚举期间，不需要虚拟机一个不漏地检查完所有执行上下文和全局的引用位置。HotSpot是如何直接得到引用位置的呢？使用一组称为**OopMap**的数据结构来实现。

一是在类加载完成后，把对象内什么偏移量上是什么类型的数据算出来；

二是即时编译过程中，也会在“特定的位置”记录下栈和寄存器哪些位置是引用。

由此，在根节点枚举时，就可以得知这些信息了，也就不用一个个从方法区等GC Roots开始找了。

##### 10.2 安全点

10.1节提到的即时编译时的“特定的位置”，称为安全点。因为实际上HotSpot不会为每条指令生成OopMap（浪费空间啊），因此只会在安全点生成。

安全点的选择：

1. 不能太少(收集器等待时间过长)也不能太频繁(会增大内存负荷)；

2. 需要考虑如何在垃圾收集发生时，让所有线程到达最近的安全点

   抢先式中断：先中断全部用户线程，如果哪个没到安全点，再运行一会儿。这个几乎不用

   主动式中断：只设置一个标志位，线程执行时会不断地主动轮询这个标志位，一旦发现中断标志为真，就在最近的安全点主动中断挂起。轮询标志的位置和安全点是重合的

   HotSpot使用内存保护陷阱的方式，使用一条test自馅指令。线程执行到test指令就会产生一个自馅异常信号，挂起等待。

##### 10.3 安全区域

解决线程处于Sleep或Blocked状态的情况。

安全区域指能够确保在某一段代码片段中，引用关系不会发生变化，因此在这个区域进行垃圾回收都是安全的。

当用户线程执行到安全区域时，会进行自我标记，垃圾收集时也不会管这些已经标识进入安全区的线程。当线程要退出安全区时，会检查虚拟机是否完成了根节点枚举，完成了则继续执行；否则等待，直到收到可以安全离开的信号为止。

##### 10.4 记忆集与卡表

记忆集Remembered Set用于解决对象跨代引用所带来的的问题。垃圾收集器在新生代建立了名为记忆集的数据结构，用以避免把整个老年代加进GC Roots扫描范围。

记忆集：一种用于记录从非收集区域指向收集区域的指针集合的**抽象**数据结构。

记忆集可以采用不同的精度：字长精度、对象精度、卡精度

卡精度是指使用“卡表”来实现记忆集，使用比较广泛。卡表是记忆集的一种**具体**实现。

卡表最简单的形式可以是一个字节数组，HotSpot就是这样实现的。

`CARD_TABLE [this address >> 9] = 0;`

字节数组的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块成为“卡页”，大小一般为2的N次幂，HotSpot默认为2^9^ ，即512字节。

一个卡页一般包含多个对象，只要有一个或多个对象的字段存在着跨代指针，那么就将对应的卡表的数组元素的值标识为1，称为这个元素变脏。垃圾收集发生时，只要筛选卡表变脏的元素，就能找到存在跨代指针的内存块，并将它们加入GC Roots中参与扫描。

##### 10.5 写屏障

卡表元素何时变脏？有其他分代区域的对象引用了本区域对象时。变脏的时间点应该发生在引用类型字段赋值的那一刻。

那么如何更新卡表嘞？

1. 在解释字节码的情况下，比较好处理，虚拟机负责每条字节码指令的执行，有充分的介入空间

2. 在即时编译时，编译后的代码已经是纯粹的机器指令流了，咋整呢？

   HotSpot通过写屏障技术来维护卡表。写屏障可以看做虚拟机层面对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时，产生一个环形通知，提供额外的动作，在赋值前的部分称为写前屏障，在赋值后的部分称为写后屏障。

上面的操作会产生额外开销，另外的，卡表在高并发场景下，还存在“伪共享”的问题。

由于现代CPU的缓存系统中是以缓存行为单位存储的，多个线程修改互相独立的变量时，可能这些变量恰好共享一个缓存行，就会影响性能。

为了解决伪共享，HotSpot解决方案是不采用无条件的写屏障，说白了就是加个判断，判断卡表是否已经被标记，只有没被标记，才会将其标记为脏。多加了一个判断，多了内存损耗。

##### 10.6 并发的可达性分析

为啥必须在一个能保障一致性的快照上才能进行对象图的遍历？可以通过**三色标记**来解释

白色：没访问过，初始都为白，结束时白色代表不可达

黑色：这个对象的所有引用都已经扫描过

灰色：这个对象上至少存在一个引用还没有被扫描过

例子p88

当且仅当以下两个条件同时满足时，会产生“对象消失”问题：

* 赋值器插入了一条或多条从黑色对象到白色对象的新引用
* 赋值器删除了全部灰色对象到该白色对象的直接或间接引用

两个解决方案：增量更新(Incremental Update)和原始快照(Snapshot At The Beginning，SATB)

* 增量更新破坏第一个条件，即插入从黑对象到白对象的新引用时，记录这个新引用，并发扫描结束后，以这些记录过的引用关系中的黑对象为根，重写扫描一次
* 原始快照破坏第二个条件，记录新的对应的删除记录，扫描结束后，再将这些记录的引用关系中的灰色对象为根，重写扫描一次。

虚拟机的记录操作都是通过**写屏障**来实现的。HotSpot中，CMS用的增量更新来做并发标记，G1用的原始快照来实现









#### 11. 垃圾回收有哪些算法

##### **11.1 标记阶段**

###### 11.1.1 **引用计数法**

1. 引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。
2. 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。
3. 优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。
4. 缺点：
   1. 它需要单独的字段存储计数器，这样的做法增加了**存储空间的开销**。
   2. 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了**时间开销**。
   3. 引用计数器有一个严重的问题，即**无法处理循环引用**的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。

###### 11.1.2 **可达性分析算法**

**可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集**

1. 相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地**解决在引用计数算法中循环引用的问题，防止内存泄漏的发生**。
2. 相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作**追踪性垃圾收集**（Tracing Garbage Collection）

实现思路：

- 所谓"GCRoots”根集合就是一组必须活跃的引用
- 其基本思路如下：

1. 可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式**搜索被根对象集合所连接的目标对象是否可达。**
2. 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为**引用链**（Reference Chain）
3. 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。
4. 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。

> 如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障**一致性的快照中**进行。这点不满足的话分析结果的准确性就无法保证。
>
> 这点也是导致GC进行时必须“stop The World”的一个重要原因。
>
> 即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。



###### 11.1.3 **GC Roots可以是哪些元素？**

1. 虚拟机栈中引用的对象
   - 比如：各个线程被调用的方法中使用到的参数、局部变量等。
2. 本地方法栈内JNI（通常说的本地方法）引用的对象
3. 方法区中类静态属性引用的对象
   - 比如：Java类的引用类型静态变量
4. 方法区中常量引用的对象
   - 比如：字符串常量池（StringTable）里的引用
5. 所有被同步锁synchronized持有的对象
6. Java虚拟机内部的引用。
   - 基本数据类型对应的Class对象，一些常驻的异常对象（如：NullPointerException、OutofMemoryError），系统类加载器。
7. 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

###### 11.1.4 **如何判断对象是生存还是死亡嘞**？

1. 如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。

   一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它立即进行回收就是不合理的。为此，定义虚拟机中的对象可能的三种状态。如下：

   1. 可触及的：从根节点开始，可以到达这个对象。
   2. 可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。
   3. 不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，**因为finalize()只会被调用一次**。

2. 以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。



##### **11.2 清除阶段**

垃圾清除阶段常见的3种收集算法：

* 标记-清除算法
* 复制算法
* 标记-压缩算法

###### 11.2.1 **标记-清除算法**

**执行过程**

当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除

1. 标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。
   - 注意：标记的是被引用的对象，也就是可达对象，并非标记的是即将被清除的垃圾对象
2. 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收

<img src="D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210421094129179.png" alt="image-20210421094129179" style="zoom:67%;" />

**标记-清除算法的缺点**

1. 标记清除算法的效率不算高
2. 在进行GC的时候，需要停止整个应用程序，用户体验较差
3. 这种方式清理出来的空闲内存是不连续的，产生内碎片，需要维护一个空闲列表

**注意：何为清除？**

这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放（也就是**覆盖**原有的地址）。

关于空闲列表是在为对象分配内存的时候提过：

1. 如果内存规整
   - 采用指针碰撞的方式进行内存分配
2. 如果内存不规整
   - 虚拟机需要维护一个空闲列表
   - 采用空闲列表分配内存

###### 11.2.2 **复制算法**

​	**核心思想**：将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收

<img src="D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210421094318131.png" alt="image-20210421094318131" style="zoom:67%;" />

新生代里面就用到了复制算法，Eden区和S0区存活对象整体复制到S1区

**复制算法的优缺点**

**优点**

1. 没有标记和清除过程，实现简单，运行高效
2. 复制过去以后保证空间的连续性，不会出现“碎片”问题。

**缺点**

1. 此算法的缺点也是很明显的，就是需要两倍的内存空间。
2. 对于G1这种分拆成为大量区域的GC，复制而不是移动，意味着GC需要维护区域之间对象引用关系，不管是内存占用或者时间开销也不小

**复制算法的应用场景**

1. 如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，效率较高
2. 老年代大量的对象存活，那么复制的对象将会有很多，效率会很低
3. 在新生代，对常规应用的垃圾回收，一次通常可以回收70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。

###### 11.2.3 **标记-压缩算法**

背景：没有针对老年代的垃圾回收算法，标记-清除有内存碎片

**执行过程**

1. 第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象
2. 第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间。

<img src="D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210421095624024.png" alt="image-20210421095624024" style="zoom:80%;" />

**标记-压缩算法与标记-清除算法的比较**

1. 标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为标记-清除-压缩（Mark-Sweep-Compact）算法。
2. 二者的本质差异在于标记-清除算法是一种**非移动式的回收算法**，标记-压缩是**移动式的**。是否移动回收后的存活对象是一项优缺点并存的风险决策。
3. 可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，当我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。

**标记-压缩算法的优缺点**

**优点**

1. 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。
2. 消除了复制算法当中，内存减半的高额代价。

**缺点**

1. 从效率上来说，标记-整理算法要低于复制算法。
2. 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址（因为HotSpot虚拟机采用的不是句柄池的方式，而是直接指针）
3. 移动过程中，需要全程暂停用户应用程序。即：STW



##### 11.3 **总结**

1. 效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。
2. 而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段。

|              |      标记清除      | 标记整理         | 复制                                  |
| ------------ | :----------------: | ---------------- | ------------------------------------- |
| **速率**     |        中等        | 最慢             | 最快                                  |
| **空间开销** | 少（但会堆积碎片） | 少（不堆积碎片） | 通常需要活对象的2倍空间（不堆积碎片） |
| **移动对象** |         否         | 是               | 是                                    |

##### 11.4 分代收集算法

**不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。**

1. 年轻代（Young Gen）
   - 年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。
   - 这种情况**复制算法**的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。
2. 老年代（Tenured Gen）
   - 老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。
   - 这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由**标记-清除**或者是**标记-清除**与**标记-整理**的混合实现。
     - Mark阶段的开销与存活对象的数量成正比。
     - Sweep阶段的开销与所管理区域的大小成正相关。
     - Compact阶段的开销与存活对象的数据成正比。
3. 以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用Serial Old执行Full GC以达到对老年代内存的整理。
4. 分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代



#### 12.GC 的全流程

对象的删除至少要经历两次标记过程：

1. 如果对象objA到GC Roots**没有引用链**，则进行**第一次标记**。
2. 进行筛选，判断此对象是否有必要执行finalize()方法
   1. 如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA被判定为不可触及的。
   2. 如果对象objA重写了finalize()方法，且还未执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的、低优先级的Finalizer线程触发其finalize()方法执行。
   3. finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，**一个对象的finalize()方法只会被调用一次**。

#### 13.GC的分类？

1. 我们都知道，JVM的调优的一个环节，也就是垃圾收集，我们需要尽量的避免垃圾回收，因为在垃圾回收的过程中，容易出现STW（Stop the World）的问题，**而 Major GC 和 Full GC出现STW的时间，是Minor GC的10倍以上**
2. JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对Hotspot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）

- 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：
  - **新生代收集**（Minor GC/Young GC）：只是新生代（Eden，s0，s1）的垃圾收集
  - **老年代收集**（Major GC/Old GC）：只是老年代的圾收集。
  - 目前，只有CMS GC会有单独收集老年代的行为。
  - 注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。
  - 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有G1 GC会有这种行为
- **整堆收集**（Full GC）：收集整个java堆和方法区的垃圾收集。

##### **年轻代 GC（Minor GC/Young GC）触发机制**

1. 当年轻代空间不足时，就会触发Minor GC，这里的年轻代满指的是Eden代满。Survivor满不会主动引发GC，在Eden区满的时候，会顺带触发s0区的GC，也就是被动触发GC（每次Minor GC会清理年轻代的内存）
2. 因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。
3. Minor GC会引发STW（Stop The World），暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行

![image-20210419202547611](D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210419202547611.png)

##### **老年代GC（MajorGC）触发机制**

1. 指发生在老年代的GC，对象从老年代消失时，我们说 “Major Gc” 或 “Full GC” 发生了
2. 出现了MajorGC，经常会伴随至少一次的Minor GC。（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行MajorGC的策略选择过程）
   - 也就是在老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足，则触发Major GC
3. Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。
4. 如果Major GC后，内存还不足，就报OOM了

##### **触发Full GC执行的情况有如下五种：**

1. 调用System.gc()时，系统建议执行FullGC，但是不必然执行
2. 老年代空间不足
3. 方法区空间不足
4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5. 由Eden区、survivor space0（From Space）区向survivor space1（To Space）区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

说明：Full GC 是开发或调优中尽量要避免的。这样STW时间会短一些



#### 14. 垃圾回收器分类

##### 14.1 分类

按**垃圾回收线程数**：串行垃圾回收器和并行垃圾回收器

串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。

- 在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中
- 在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。

和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“stop-the-world”机制。

![image-20210421142520075](D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210421142520075.png)

按**工作模式**：并发式垃圾回收器和独占式垃圾回收器(Stop the World)

- 并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。
- 独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。

![image-20210421142559050](D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210421142559050.png)

其他的还有：压缩式和非压缩式，很好理解，就是清理完后是否进行压缩整理；还有年轻代垃圾收集器和老年代。。。。

##### 14.2 **评估GC的性能指标**

吞吐量：运行用户代码的时机占总运行时间的比例

垃圾收集开销、暂停时间、收集频率、内存占用

设计垃圾收集器需要权衡吞吐量和暂停时间，目前的标准是：**在最大吞吐量优先的情况下，降低停顿时间**

##### 14.3 **7个经典的垃圾回收器**

1. 串行回收器：Serial、Serial old
2. 并行回收器：ParNew、Parallel Scavenge、Parallel old
3. 并发回收器：CMS、G1

从分代来看

1. 新生代收集器：Serial、ParNew、Parallel Scavenge；
2. 老年代收集器：Serial old、Parallel old、CMS；
3. 整堆收集器：G1；

##### 14.4 **Serial回收器：串行回收**

Serial收集器作为HotSpot中client模式下的默认新生代垃圾收集器。

Serial收集器采用**复制算法**、**串行回收**和**"stop-the-World"**机制的方式执行内存回收。

除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial old收集器。Serial old收集器同样也采用了**串行回收**和**"stop the World"**机制，只不过内存回收算法使用的是**标记-压缩算法**。

- Serial old是运行在Client模式下默认的老年代的垃圾回收器
- Serial 0ld在Server模式下主要有两个用途：
  - 与新生代的Parallel scavenge配合使用
  - 作为老年代CMS收集器的后备垃圾收集方案

![image-20210421142814442](D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210421142814442.png)

**Serial 回收器的优势**：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。

是HotSpot客户端模式下，默认新生代收集器

总结：现在都木有单核的了，所以基本不用这玩意儿了~



##### 14.5 **ParNew回收器：并行回收**

1. 如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。

   > Par是Parallel的缩写，New：只能处理新生代

2. ParNew 收集器除了采用**并行回收**的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用**复制算法**、**"Stop-the-World"**机制。

3. ParNew 是很多JVM运行在Server模式下新生代的默认垃圾收集器。

![image-20210421143344184](D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210421143344184.png)

1. 对于新生代，回收次数频繁，使用并行方式高效。
2. 对于老年代，回收次数少，使用串行方式节省资源。（CPU并行需要切换线程，串行可以省去切换线程的资源）



> GC中的并发和并行：
>
> 并行(Parallel)：多条垃圾收集器线程协同工作，通常默认此时用户线程阻塞，即STW
>
> 并发(Concurrent)：同一时间垃圾收集器线程和用户线程都在运行，此时用户线程不阻塞，仍能响应服务请求，但由于垃圾收集器线程也在运行，因此吞吐量将受到影响



##### 14.6 **Parallel回收器：吞吐量优先**

**Parallel Scavenge 回收器：吞吐量优先**

1. HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavenge收集器同样也采用了**复制算法**、**并行回收**和**"Stop the World"**机制。
2. 那么Parallel收集器的出现是否多此一举？
   - 和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个**可控制的吞吐量**（Throughput），它也被称为吞吐量优先的垃圾收集器。
   - **自适应调节策略**也是Parallel Scavenge与ParNew一个重要区别。（动态调整内存分配情况，以达到一个最优的吞吐量或低延迟）
3. 高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，**主要适合在后台运算而不需要太多交互的任务**。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。
4. Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。
5. Parallel Old收集器采用了**标记-压缩算法**，但同样也是基于**并行回收**和**"Stop-the-World"**机制。

![image-20210421143625347](D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210421143625347.png)

1. 在程序吞吐量优先的应用场景中，Parallel收集器和Parallel Old收集器的组合，在server模式下的内存回收性能很不错。
2. **在Java8中，默认是此垃圾收集器。**

**Parallel Scavenge 回收器参数设置**

1. `-XX:+UseParallelGC` ：手动指定年轻代使用Parallel并行收集器执行内存回收任务。
2. `-XX:+UseParallelOldGC`：手动指定老年代都是使用并行回收收集器。
   - 分别适用于新生代和老年代
   - 上面两个参数分别适用于新生代和老年代。默认jdk8是开启的。默认开启一个，另一个也会被开启。（互相激活）
3. `-XX:ParallelGCThreads`：设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。
   1. 在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。
   2. 当CPU数量大于8个，ParallelGCThreads的值等于`3 + [5 * CPU_Count] / 8]`
4. `-XX:MaxGCPauseMillis` 设置垃圾收集器**最大停顿时间**（即STW的时间）。单位是毫秒。
   1. 为了尽可能地把停顿时间控制在`XX:MaxGCPauseMillis` 以内，收集器在工作时会调整Java堆大小或者其他一些参数。
   2. 对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。
   3. 该参数使用需谨慎。如果设置过小，JVM会缩小新生代的大小，使得GC发生更频繁，导致停顿时间小，但吞吐量也下降。
5. `-XX:GCTimeRatio`垃圾收集时间占总时间的比例，即等于 1 / (N+1) ，用于衡量吞吐量的大小。
   1. 取值范围(0, 100)。默认值99，也就是垃圾回收时间占比不超过1。
   2. 与前一个-XX:MaxGCPauseMillis参数有一定矛盾性，STW暂停时间越长，Radio参数就容易超过设定的比例。

6. `-XX:+UseAdaptiveSizePolicy` 设置Parallel Scavenge收集器具有**自适应调节策略**
   1. 在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。
   2. 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMillis），让虚拟机自己完成调优工作。

##### **14.7 CMS回收器：低延迟**

1. 在JDK1.5时期，Hotspot推出了一款在**强交互应用中（就是和用户打交道的应用）**几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，**这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。**
2. CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。
   - 目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。
3. CMS的垃圾收集算法采用**标记-清除算法**，并且也会**"Stop-the-World"**
4. 不幸的是，CMS作为老年代的收集器，却无法与JDK1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作（因为实现的框架不一样，没办法兼容使用），所以在JDK1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。
5. 在G1出现之前，CMS使用还是非常广泛的。一直到今天，仍然有很多系统使用CMS GC。

![image-20210421144533437](D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210421144533437.png)

###### CMS过程的四阶段

CMS整个过程比之前的收集器要复杂，整个过程分为4个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段。(涉及STW的阶段主要是：初始标记 和 重新标记)

1. 初始标记（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，**这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象**。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的**速度非常快**。
2. 并发标记（Concurrent-Mark）阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是**不需要停顿用户线程**，**可以与垃圾收集线程一起并发运行**。
3. 重新标记（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录**（就是增量更新~）**，这个阶段的停顿时间通常会比初始标记阶段稍长一些，并且也会导致“Stop-the-World”的发生，但也远比并发标记阶段的时间短。
4. 并发清除（Concurrent-Sweep）阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。**由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的**

###### CMS分析：

1. 尽管CMS收集器采用的是并发回收（非独占式），**但是在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制**暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“Stop-the-World”，只是尽可能地缩短暂停时间。
2. **由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的**。
3. 另外，由于在垃圾收集阶段用户线程没有中断，所以在CMS回收过程中，还应该确保应用程序用户线程有足够的内存可用。因此，CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，**而是当堆内存使用率达到某一阈值时，便开始进行回收**，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次**“Concurrent Mode Failure”** 失败，这时虚拟机将启动**后备预案**：临时启用**Serial old收集器**来重新进行老年代的垃圾收集，这样停顿时间就很长了。
4. CMS收集器的垃圾收集算法采用的是**标记-清除算法**，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，**不可避免地将会产生一些内存碎片**。那么CMS在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。

![image-20210421144644130](D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210421144644130.png)



###### **为什么 CMS 不采用标记-压缩算法呢？**

答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“stop the world”这种场景下使用



###### CMS的优缺点

**优点**

1. 并发收集
2. 低延迟

**弊端**

1. **会产生内存碎片**，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发Full GC。

2. **CMS收集器对CPU资源非常敏感**。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。

3. **CMS收集器无法处理浮动垃圾**。可能出现“Concurrent Mode Failure"并发失败而导致另一次Full GC的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，**那么在并发标记阶段如果产生新的垃圾对象，CMS将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收，**从而只能在下一次执行GC时释放这些之前未被回收的内存空间。

   由此，CMS会预留一部分空间，供并发清除时分配新对象使用

**总结**：JDK9会警告CMS未来会被弃用；JDK14删除CMS垃圾回收器



##### **14.8 G1回收器：区域化分代式**

> 介绍G1和其他的区别？介绍分区概念；如何解决跨区域引用(记忆集的实现)？如何解决并发时的问题(原始快照->写前屏障)？如何实现停顿预测模型(分区、帅减均值、队列、排序)？G1回收的过程？优缺点

###### 为啥会出现G1？

**既然我们已经有了前面几个强大的 GC ，为什么还要发布 Garbage First（G1）GC？**

1. 原因就在于应用程序所应对的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序正常进行，而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。
3. 与此同时，**为了适应现在不断扩大的内存和不断增加的处理器数量**，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。
4. 官方给G1设定的目标是**在延迟可控的情况下获得尽可能高的吞吐量**，所以才担当起“全功能收集器”的重任与期望。

###### **为什么名字叫Garbage First(G1)呢？**

1. 因为G1是一个**并行**回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的区域来表示Eden、幸存者0区，幸存者1区，老年代等。
2. G1 GC有计划地**避免**在整个Java堆中进行**全区域**的垃圾收集。G1跟踪各个区域里面的垃圾堆积的**价值大小**（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个**优先列表**，每次根据允许的收集时间，**优先回收价值最大的Region**。
3. 由于这种方式的侧重点在于**回收垃圾最大量的区域**，所以我们给G1一个名字：垃圾优先（Garbage First）。
4. G1（Garbage-First）是一款**面向服务端应用**的垃圾收集器，主要针对配备**多核CPU及大容量内存**的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征。
5. 在JDK1.7版本正式启用，移除了Experimental的标识，**是JDK9以后的默认垃圾回收器**，取代了CMS回收器以及Parallel+Parallel Old组合。被Oracle官方称为**“全功能的垃圾收集器”**。
6. 与此同时，CMS已经在JDK9中被标记为废弃（deprecated）。**G1在JDK8中还不是默认的垃圾回收器**，需要使用-XX:+UseG1GC来启用。

###### **G1的优势**

与其他GC收集器相比，G1使用了全新的分区算法，其特点如下所示：

1. **并行与并发兼备**
   - 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW
   - 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况
2. **分代收集**
   - 从分代上看，G1依然属于**分代型垃圾回收器**，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。
   - 将堆空间分为若干个**区域**（Region），这些区域中包含了**逻辑上**的**年轻代**和**老年代**。
   - 和之前的各类回收器不同，它**同时兼顾年轻代和老年代**。对比其他回收器，或者工作在年轻代，或者工作在老年代；

![image-20210421150110403](D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210421150110403.png)

###### **空间整合**

1. CMS：标记-清除算法、内存碎片、若干次GC后进行一次碎片整理
2. G1将内存划分为一个个的区域。内存的回收是以区域作为基本单位的。**区域之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法**，两种算法都可以**避免内存碎片**。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。

###### **可预测的停顿时间模型（即：软实时soft real-time）**

这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

G1的停顿预测模型是以**衰减均值**为理论基础来实现的。G1会记录每个区域的回收耗时、每个区域记忆集里的脏卡数量等数据，并分析得出平均值、标准偏差、置信度等信息。这里衰减均值更容易受到新数据的影响。平均值代表整体平均状态，衰减均值更准确地代表“最近的”平均状态。

>  相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。

###### **分区Region**

**分区 Region：化整为零**

1. 使用G1收集器时，它将整个Java堆划分成约**2048个**大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，**整体**被控制在**1MB到32MB之间**，且**为2的N次幂**，即1MB，2MB，4MB，8MB，16MB，32MB。可以通过`XX:G1HeapRegionSize`设定。**所有的Region大小相同，且在JVM生命周期内不会被改变。**
2. 虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是**一部分Region（不需要连续）的集合**。通过Region的动态分配方式实现**逻辑上的连续**。空的Region内存，通过一个空闲链表LinkedList来维护
3. 一个Region有可能属于Eden，Survivor或者Old/Tenured内存区域。但是**一个Region只可能属于一个角色**。图中的E表示该Region属于Eden内存区域，S表示属于Survivor内存区域，O表示属于Old内存区域。图中空白的表示未使用的内存空间。
4. G1垃圾收集器还增加了一种新的内存区域，叫做**Humongous内存区域**，如图中的H块。主要用于**存储大对象**，如果**超过0.5个Region，就放到H**。

![image-20210421151539886](D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210421151539886.png)

###### **设置 H 的原因**

对于堆中的大对象，默认直接会被分配到老年代，但是如果**它是一个短期存在的大对象**就会对垃圾收集器造成负面影响。为了解决这个问题，G1划分了一个Humongous区，它用来专门存放大对象。如**果一个H区装不下一个大对象，那么G1会寻找连续的H区来存储**。为了能找到连续的H区，有时候不得不启动Full GC。G1的大多数行为都把H区作为老年代的一部分来看待。

**Region的细节**

![image-20210421151612694](D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210421151612694.png)

1. 每个Region都是通过**指针碰撞**来分配空间
2. G1为每一个Region设 计了**两个**名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的**新对象分配**，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1认为指针地址以上的为存活的，不进行回收。
3. TLAB还是用来保证并发性



###### G1在并发标记阶段如何保证收集线程与用户线程互不干扰？

之前也提过并发标记的解决方案，CMS采用增量更新实现，而G1采用**原始快照**实现。

为了实现原始快照(SATB)算法，G1使用**写前屏障**来跟踪并发时的指针变化情况。



###### Remembered Set 记忆集

> 前面HotSpot实现部分也记录过，卡表是RSet的具体实现

1. 一个对象被不同区域引用的问题
2. 一个Region不可能是孤立的，一个Region中的对象可能被其他任意Region中对象引用，判断对象存活时，是否需要扫描整个Java堆才能保证准确？
3. 在其他的分代收集器，也存在这样的问题（而G1更突出，因为G1主要针对大堆）
4. 回收新生代也不得不同时扫描老年代？这样的话会降低Minor GC的效率

**解决方法：**

1. 无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全堆扫描；
2. 每个区域都有一个对应的Remembered Set
3. 每次引用类型数据写操作时，都会产生一个**写后屏障**暂时中断操作；
4. 然后检查将要写入的引用指向的对象是否和该引用类型数据在不同的区域（其他收集器：检查老年代对象是否引用了新生代对象）；
5. 如果不同，通过卡表CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中；
6. 当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。

![image-20210421151805269](D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210421151805269.png)

**G1中记忆集的实现：**

每个Region都有自己的记忆集，会记录别的Region指向自己的指针，还会记录这些指针分别在哪些卡页(卡表的索引号)的范围内。也就是记录了哪些分区引用了当前分区的对象，只需扫描这些对象就可以了。并且只需记录老年代到新生代的即可。

本质上是一个哈希表，key是别的Region的起始地址，value是一个集合，里面存储的元素是卡表的索引号。

这种“双向”的卡表结构，实现比普通的卡表更加复杂。因此G1比其他的垃圾收集器更高的内存消耗。

> 卡表之前也介绍过，就是不用每个引用都记录，这样开销很大的。一个卡表将一个分区从逻辑上划分为固定大小的连续区域(卡页)，只要一个卡页有一个对象被引用，就会被标识为脏页，并将该页的index记录在哈希表的Value集合中

**小结：**

1. 在回收 Region 时，为了不进行全堆的扫描，引入了 Remembered Set
2. Remembered Set 记录了当前 Region 中的对象被哪个对象引用了
3. 这样在进行 Region 复制时，就不要扫描整个堆，只需要去 Remembered Set 里面找到引用了当前 Region 的对象
4. Region 复制完毕后，修改 Remembered Set 中对象的引用即可



###### G1垃圾回收的流程

G1 GC的垃圾回收过程主要包括如下三个环节：

- 年轻代GC（Young GC）
- 老年代并发标记过程（Concurrent Marking）
- 混合回收（Mixed GC）
- （如果需要，单线程、独占式、高强度的Full GC还是继续存在的。它针对GC的评估失败提供了一种失败保护机制，即强力回收。）

![image-20210421151649504](D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210421151649504.png)

![image-20210423142502879](D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210423142502879.png)

顺时针，Young GC --> Young GC+Concurrent Marking --> Mixed GC顺序，进行垃圾回收

**回收流程**

1. 应用程序分配内存，当年轻代的**Eden区用尽**时**开始年轻代**回收过程；G1的**年轻代**收集阶段是一个**并行**的**独占式**收集器。在年轻代回收期，G1 GC**暂停所有应用程序线程**，启动**多线程**执行年轻代回收。然后从年轻代区间移动存活对象到Survivor区间或者老年区间，也有可能是两个区间都会涉及。
2. 当堆内存使用达到一定值（默认45%）时，开始老年代**并发标记**过程。
3. 标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的G1回收器和其他GC不同，**G1的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的Region就可以了**。同时，这个老年代Region是和年轻代一起被回收的。
4. 举个例子：一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存。G1会每45秒钟进行一次年轻代回收，每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。





###### G1回收过程一：年轻代GC

1. JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。
2. 年轻代回收只回收Eden区和Survivor区
3. YGC时，首先G1停止应用程序的执行（Stop-The-World），G1创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。

![image-20210421151917231](D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210421151917231.png)

图的大致意思就是：

1、回收完E和S区，剩余存活的对象会**复制**到新的S区

2、S区达到一定的阈值可以晋升为O区

**细致过程：**

**然后开始如下回收过程：**

1. 第一阶段，扫描根

   根是指GC Roots，包括**静态变量**static指向的对象，正在执行的方法调用链条上的**局部变量**等。根引用连同**Remembered Set记录的外部引用**作为扫描存活对象的入口。

2. 第二阶段，更新Remembered Set

   **处理dirty card queue**（见备注）中的card，**更新RSet**。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。

3. 第三阶段，处理Remembered Set

   识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。

4. 第四阶段，复制对象(和堆那部分介绍的一样)

   - 此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段
   - Survivor区内存段中存活的对象，如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到Old区中空的内存分段。
   - 如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。

5. 第五阶段，处理引用 (软引用、弱引用、虚引用等等)

   处理Soft，Weak，Phantom，Final，JNI Weak 等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。

**备注：**

1. 对于应用程序的引用赋值语句 `oldObject.field（这个是老年代）=object（这个是新生代）`，JVM会通过**写屏障**在之前和之后执行特殊的操作以在dirty card queue中入队一个保存了对象引用信息的card。在年轻代回收的时候，G1会对Dirty Card Queue中所有的card进行处理，以更新RSet，保证RSet实时准确的反映引用关系。
2. 那为什么不在引用赋值语句处直接更新RSet呢？这是为了性能的需要，RSet的处理需要线程同步，开销会很大，使用队列性能会好很多。



###### G1回收过程二：并发标记过程

1. 初始标记阶段：标记从**根节点直接可达的对象**。这个阶段是**STW**的，并且会触发一次年轻代GC。正是由于该阶段是STW的，所以我们只扫描根节点可达的对象，以节省时间。
2. 根区域扫描（Root Region Scanning）：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在Young GC之前完成，因为Young GC会使用复制算法对Survivor区进行GC。
3. 并发标记（Concurrent Marking）：
   1. 在整个堆中进行并发标记（和应用程序并发执行），此过程可能被Young GC中断。
   2. **在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。**
   3. 同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。
4. 再次(最终)标记（Remark/Final Marking）：由于应用程序持续进行，需要修正上一次的标记结果。短暂的STW。G1中采用了比CMS更快的**原始快照**算法：Snapshot-At-The-Beginning（SATB）。
5. 独占清理（cleanup，STW）：计算各个区域的存活对象和GC回收比例，并进行**排序**，识别可以混合回收的区域。为下阶段做**铺垫**。是**STW**的。这个阶段并不会实际上去做垃圾的收集
6. 并发清理阶段：识别并清理完全空闲的区域。



###### G1回收过程三：混合回收过程

当越来越多的对象晋升到老年代Old Region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region，还会回收**一部分**的Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。

![image-20210421152013694](D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210421152013694.png)

**混合回收的细节**

1. 并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置）被回收。【意思就是一个Region会被分为8个内存段】
2. 混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。
3. 由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收。XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是**垃圾占内存分段比例要达到65%才会被回收**。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。
4. 混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为10%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。



###### G1回收可选的过程四：Full GC

1. G1的初衷就是要避免Full GC的出现。但是如果上述方式不能正常工作，G1会停止应用程序的执行（Stop-The-World），使用**单线程**的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。
2. 要避免Full GC的发生，一旦发生Full GC，需要对JVM参数进行调整。什么时候会发生Ful1GC呢？比如堆内存太小，当G1在复制存活对象的时候没有空的内存分段可用，则会回退到Full GC，这种情况可以通过增大内存解决。

导致G1 Full GC的原因可能有两个：

1. EVacuation的时候没有足够的to-space来存放晋升的对象；
2. 并发处理过程完成之前空间耗尽。



###### G1补充

从Oracle官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到G1只是回一部分Region，停顿时间是用户可控制的，所以并不迫切去实现，**而选择把这个特性放到了G1之后出现的低延迟垃圾收集器（即ZGC）中。**另外，还考虑到G1不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。

**G1 回收器的优化建议**

1. 年轻代大小
   - 避免使用-Xmn或-XX:NewRatio等相关选项显式设置年轻代大小，因为固定年轻代的大小会覆盖可预测的暂停时间目标。我们让G1自己去调整
2. 暂停时间目标不要太过严苛
   - G1 GC的吞吐量目标是90%的应用程序时间和10%的垃圾回收时间
   - 评估G1 GC的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。

###### **G1的缺点**

1. 相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，**G1**无论是为了垃圾收集产生的**内存占用**（Footprint）还是程序运行时的**额外执行负载**（overload）都要**比CMS要高**。
2. 从经验上来说，在小内存应用上CMS的表现大概率会优于G1，而**G1在大内存应用上**则发挥其**优势**。平衡点在6-8GB之间。

###### G1 VS CMS

1. G1的卡表更加复杂，更新维护卡表需要额外的操作
2. G1的原始快照算法，需要通过写前屏障来跟踪并发时指针的变化，会带来额外的负担，需要消耗更多的资源。
3. CMS的写屏障实现时直接的同步操作；而G1的写屏障则是通过类似消息队列的结构，把写前屏障和写后屏障要做的事放在队列中，然后异步处理

###### **G1使用的场景**

1. 面向服务端应用，针对具有**大内存、多处理器**的机器。（在普通大小的堆里表现并不惊喜）
2. 最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案；
3. 如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒；（G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长）。
4. 用来替换掉JDK1.5中的CMS收集器；在下面的情况时，使用G1可能比CMS好：
   - 超过50%的Java堆被活动数据占用；
   - 对象分配频率或年代提升频率变化很大；
   - GC停顿时间过长（长于0.5至1秒）
5. HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器均使用内置的JVM线程执行GC的多线程操作，而**G1 GC可以采用应用线程承担后台运行的GC工作**，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。

##### 14.9 垃圾回收器总结

![image-20210421155319744](D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210421155319744.png)



##### 14.10 新一代垃圾回收器ZGC

https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html

###### 14.10.1 设计目标

* 停顿时间低于10ms

* 停顿时间不会随着堆的大小的增大而增加

* 支持8MB~4TB级别的堆

  ZGC适用于大内存低延迟服务的内存管理和回收

###### 14.10.2 



#### 14.对象分配的过程

new的对象首先放在Eden区，当Eden区满了后，会触发GC操作(Minor GC)。第一次GC时，会回收Eden区中不用的对象，剩余的对象会被放入S0区，并且每个对象的年龄计数器加1。

同时，Eden继续存放对象，当Eden再次存满时，又会触发Minor GC操作，这时GC会把Eden和Survivor From(S0)中的对象进行一次垃圾回收，把存活的对象存入Survivor To(S1)区，并且年龄加1

> 这里的Survivor From 和 Survivor To不是固定的，每次GC后都转换，空的那个是Survivor To

不断存放对象后，幸存区的对象年龄达到阈值(可以自己设定)，将会触发一次Promotion(晋升)操作，将达到年龄阈值的对象，放入老年代

**特殊情况**(大对象)

如果新对象Eden放不下，会进行一次YGC/MinorGC，看看GC后放不放得下；若还是放不下，看看老年代放不放得下，若放不下，则进行FGC(FullGC)，GC后若老年代仍然放不下，则OOM

#### 15.空间分配担保？

在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间。

- 如果大于，则此次Minor GC是安全的

- 如果小于，则虚拟机会查看**-XX:HandlePromotionFailure**设置值是否允担保失败。

  - 如果HandlePromotionFailure=true，那么会继续检查

    老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小

    - 如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的；
    - 如果小于，则进行一次Full GC。

  - 如果HandlePromotionFailure=false，则进行一次Full GC。

    > 现在这个参数不再用了，默认是true

#### **16.堆是分配对象的唯一选择吗？**

不一定，**如果经过逃逸分析后发现，一个对象并没有逃逸出方法的话，那么可能就被优化成栈上分配。**无需再堆上分配内存、垃圾回收

**逃逸分析**

分析对象动态作用域：

当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸

当一个对象在方法中被定义后，他被外部方法引用，则认为发生逃逸。例如作为调用参数传到其他地方

**基于逃逸分析，编译器代码优化：**栈上分配、同步省略、分离对象或标量替换

**栈上分配**：对象没有发生逃逸则在栈上分配

**同步省略**：借助逃逸分析，**判断同步块所使用的的锁对象是否只能被一个线程访问而没有发布到其他线程**，如果没有，编译器会取消同步，这称为**同步省略**或**锁消除**

**标量替换**：在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。

**逃逸分析的不足**：逃逸分析会消耗性能，如果一个对象是不逃逸的，那么分析的性能就浪费了嗷

> **在HotSpot虚拟机上，所有的对象实例都是创建在堆上**。



##### 永久代为什么要被元空间替代？

1. 永久代设置空间大小很难确定，动态加载类过多容易OOM。

   元空间在本地内存中，并不在虚拟机中，因此大小仅受本地内存限制

2. 永久代垃圾回收比较困难。



#### 17.对象的创建步骤

##### **1、判断对象对应的类是否加载、链接、初始化**

1. 虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。（即判断类元信息是否存在）。
2. 如果该类没有加载，那么在双亲委派模式下，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的.class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。

##### **2、为对象分配内存**

1. 首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小
2. 如果内存规整：采用指针碰撞分配内存
   - 如果内存是规整的，那么虚拟机将采用的是指针碰撞法（Bump The Point）来为对象分配内存。
   - 意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针往空闲内存那边挪动一段与对象大小相等的距离罢了。
   - 如果垃圾收集器选择的是Serial ，ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带Compact（整理）过程的收集器时，使用指针碰撞。
   - 标记压缩（整理）算法会整理内存碎片，堆内存一存对象，另一边为空闲区域
3. 如果内存不规整
   - 如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。
   - 意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为了 “空闲列表（Free List）”
   - 选择哪种分配方式由Java堆是否规整所决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
   - 标记清除算法清理过后的堆内存，就会存在很多内存碎片。

##### **3、处理并发问题**

1. 采用CAS+失败重试保证更新的原子性
2. 每个线程预先分配TLAB - 通过设置 -XX:+UseTLAB参数来设置（区域加锁机制）
3. 在Eden区给每个线程分配一块区域

##### **4、初始化分配到的空间**

- 所有属性设置默认值，保证对象实例字段在不赋值可以直接使用
- 给对象属性赋值的顺序：

1. 属性的默认值初始化
2. 显示初始化/代码块初始化（并列关系，谁先谁后看代码编写的顺序）
3. 构造器初始化

##### **5、设置对象的对象头**

将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。

> 对象在内存中存储分为三块区域：对象头、实例数据、对齐填充
>
> 对象头：一部分存储对象自身运行时数据，如GC分代年龄、哈希码、锁状态、线程持有的锁等；另一部分用于存储对象的类元数据的指针，用来确定这个对象属于哪个类
>
> 实例数据：程序代码中定义的各种类型的字段内容，包括父类继承来的
>
> 对齐填充：对象的大小要求8字节的整数倍

##### **6、执行init方法进行初始化**

1. 在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量
2. 因此一般来说（由字节码中跟随invokespecial指令所决定），new指令之后会接着就是执行init方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。

<img src="D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210419220121460.png" alt="image-20210419220121460" style="zoom:67%;" />



#### 18.对象如何访问滴？

<img src="D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210419220313457.png" alt="image-20210419220313457" style="zoom: 50%;" />

对象访问的两种方式

##### **句柄访问**

1. 缺点：在堆空间中开辟了一块空间作为句柄池，句柄池本身也会占用空间；通过两次指针访问才能访问到堆中的对象，效率低
2. 优点：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference本身不需要被修改

<img src="D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210419220350207.png" alt="image-20210419220350207" style="zoom:67%;" />

##### **直接指针（HotSpot采用）**

1. 优点：直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据
2. 缺点：对象被移动（垃圾收集时移动对象很普遍）时需要修改 reference 的值

<img src="D:%5CProgram%20Data%5CTypora%5Ctypora-user-images%5Cimage-20210419220451947.png" alt="image-20210419220451947" style="zoom:67%;" />



#### 19.执行引擎

##### 19.1 解释器和 JIT 编译器

1. 解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用**逐行**解释的方式**执行**，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。实现跨平台特性
2. JIT（Just In Time Compiler）编译器：就是虚拟机将源代码**一次性直接**编译成和本地机器平台相关的机器语言，**但并不是马上执行**。JIT编译器将字节码翻译成本地代码后，就可以做一个缓存操作，存储在方法区的CodeCache中（执行效率更高了），并且在翻译成本地代码的过程中可以做优化。



##### 19.2 编译器辣么快，为啥还要解释器嘞？

**首先明确两点：**

1. 当程序启动后，解释器可以马上发挥作用，**响应速度快**，省去编译的时间，立即执行。
2. 编译器要想发挥作用，把代码编译成本地代码，**需要一定的执行时间**，但编译为本地代码后，执行效率高。

**所以：**

1. 尽管JRockit VM中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。
2. 在此模式下，在Java虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。
3. 同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”（后备方案）。



##### 19.3 热点代码及探测方式

1. 当然是否需要启动JIT编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用**执行的频率**而定。

2. 关于那些需要被编译为本地代码的字节码，也被称之为**“热点代码”**，JIT编译器在运行时会针对那些频繁被调用的“热点代码”做出**深度优化**，将其直接编译为对应平台的本地机器指令，以此提升Java程序的执行性能。

3. 一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR (On StackReplacement)编译。

4. 一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。

5. **目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测**。

6. 采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法**调用计数器**（Invocation Counter）和**回边计数器**（Back Edge Counter）。

   1. 方法调用计数器用于统计方法的调用次数
   2. 回边计数器则用于统计循环体执行的循环次数

   

##### 19.4 方法调用计数器的热度衰减

1. 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即**一段时间之内方法被调用的次数**。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减（Counter Decay），而这段时间就称为此方法统计的半衰周期（Counter Half Life Time）（半衰周期是化学中的概念，比如出土的文物通过查看C60来获得文物的年龄）
2. 进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 -XX:-UseCounterDecay 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样的话，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。
3. 另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。



##### 19.5 HotSpot JIT 分类

1. -client：指定Java虚拟机运行在Client模式下，并使用C1编译器；
   - C1编译器会对字节码进行简单和可靠的优化，耗时短，以达到更快的编译速度。
2. -server：指定Java虚拟机运行在server模式下，并使用C2编译器。
   - C2进行耗时较长的优化，以及激进优化，但优化的代码执行效率更高。（使用C++）

